<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Volumetric Poop Interaction</title>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d0d0d;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .status-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            max-width: 300px;
        }
        h1 {
            margin: 0 0 5px 0;
            font-size: 1.2rem;
            color: #d4af37; /* ÊöóÈáëËâ≤ */
        }
        p {
            margin: 0;
            font-size: 0.9rem;
            color: #aaa;
            line-height: 1.4;
        }
        .indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #333;
            transition: background-color 0.3s ease;
        }
        .indicator.active {
            background-color: #00ff88;
            box-shadow: 0 0 5px #00ff88;
        }
        .indicator.error {
            background-color: #ff4444;
        }
        
        /* Video preview */
        .input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.1);
            z-index: 10;
            transform: scaleX(-1);
            opacity: 0.5;
            display: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            font-size: 1.2rem;
            z-index: 20;
            text-align: center;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="loading">Ê≠£Âú®Âä†ËΩΩ 3D ÂºïÊìé‰∏éËßÜËßâÊ®°Âûã...</div>

    <div id="ui-layer">
        <div class="status-box">
            <h1>üí© Á≤íÂ≠ê‰æø‰æø v3.1 (ÂÖâÁÖß‰øÆÂ§çÁâà)</h1>
            <p><span id="cam-status" class="indicator"></span>ÊëÑÂÉèÂ§¥: <span id="cam-text">ÂàùÂßãÂåñ...</span></p>
            <p><span id="hand-status" class="indicator"></span>ÊâãÂäø: <span id="gesture-text">Á≠âÂæÖÊâãÈÉ®...</span></p>
            <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin:10px 0;">
            <p style="font-size: 0.85rem; color: #888;">
                1. ‚úä <b>Êè°Êã≥</b> = ËÅöÂêàÂÆû‰Ωì<br>
                2. üñê <b>Âº†Êâã</b> = Êï£ÂºÄÊºÇÊµÆ<br>
                (ÊîØÊåÅÈº†Ê†áÁÇπÂáª/ÈïøÊåâ)
            </p>
        </div>
    </div>

    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <!-- Vertex Shader -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uProgress; // 0.0 = scattered, 1.0 = gathered
        
        attribute vec3 aTargetPos;
        attribute float aSize;
        attribute vec3 aRandomPos;
        attribute float aSpeed; 
        
        varying vec3 vColor;
        varying float vAlpha;

        // --- Noise Functions ---
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) { 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i); 
            vec4 p = permute( permute( permute( 
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                        dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vColor = color;
            
            vec3 driftOffset;
            driftOffset.x = sin(uTime * 0.2 * aSpeed + aRandomPos.y) * 2.0;
            driftOffset.y = cos(uTime * 0.15 * aSpeed + aRandomPos.x) * 2.0;
            driftOffset.z = sin(uTime * 0.1 * aSpeed + aRandomPos.z) * 2.0;
            vec3 animatedRandomPos = aRandomPos + driftOffset;

            float noiseVal = snoise(vec3(aTargetPos.x * 0.1, aTargetPos.y * 0.1 + uTime * 0.5, aTargetPos.z * 0.1));
            vec3 breathingOffset = normalize(aTargetPos) * noiseVal * 0.5;
            vec3 animatedTargetPos = aTargetPos + breathingOffset;

            vec3 pos = mix(animatedRandomPos, animatedTargetPos, uProgress);

            float swirlStrength = sin(uProgress * 3.14159);
            float angle = swirlStrength * 2.0 * (1.0 - (pos.y + 10.0)/20.0);
            float c = cos(angle);
            float s = sin(angle);
            float xNew = pos.x * c - pos.z * s;
            float zNew = pos.x * s + pos.z * c;
            pos.x = xNew;
            pos.z = zNew;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = (aSize * 0.9) * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;

        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if(dist > 0.5) discard;
            
            float alpha = 1.0 - (dist * 2.0);
            alpha = alpha * alpha * alpha; 

            gl_FragColor = vec4(vColor, alpha * 0.6); 
        }
    </script>

    <script>
        // --- 1. Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0d0d0d, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;
        camera.position.y = 5;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = true;
        container.appendChild(renderer.domElement);

        // --- 2. Particle Generation Logic ---

        const PARTICLE_COUNT = 28000; // More particles for better definition
        const geometry = new THREE.BufferGeometry();
        
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const randomPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const speeds = new Float32Array(PARTICLE_COUNT);

        const colorShadow = new THREE.Color(0x3B2F2F); // Very Dark Brown (Crevices)
        const colorBase = new THREE.Color(0x8B4513);   // Saddle Brown (Main)
        const colorHighlight = new THREE.Color(0xFFD700); // Gold (Highlights)
        
        const tempColor = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const t = i / PARTICLE_COUNT; // 0 to 1
            
            // --- 1. Shape Strategy: Classic Spiral Cone ---
            
            const totalHeight = 18.0; 
            const startY = -9.0;
            // Linear height for predictable shape
            const centerY = startY + t * totalHeight; 

            // 3.5 Loops is the "Golden Ratio" of Poop Emojis
            const loops = 3.5;
            const coilAngle = t * Math.PI * 2 * loops;
            
            // Cone Shape: Path Radius
            // Wide at bottom (8.0), Tapers to almost center (0.5) at top
            const pathRadius = 8.0 * (1.0 - t * 0.95); 

            // Tube Thickness
            const maxTubeRadius = 3.2 * (1.0 - t * 0.6); 

            // --- 2. Volumetric Coordinates ---
            const sectionAngle = Math.random() * Math.PI * 2;
            const rOffset = Math.sqrt(Math.random()) * maxTubeRadius;

            const localR = rOffset * Math.cos(sectionAngle); 
            const localY = rOffset * Math.sin(sectionAngle); 

            const finalX = (pathRadius + localR) * Math.cos(coilAngle);
            const finalZ = (pathRadius + localR) * Math.sin(coilAngle);
            const finalY = centerY + localY;

            targetPositions[i * 3] = finalX;
            targetPositions[i * 3 + 1] = finalY;
            targetPositions[i * 3 + 2] = finalZ;

            // --- 3. Color Logic (Contrast for Shape Definition) ---
            
            const verticalFactor = Math.sin(sectionAngle); 
            const outerFactor = Math.cos(sectionAngle); 
            
            tempColor.copy(colorBase);

            if (Math.abs(verticalFactor) > 0.8) {
                // CREVICE: Darken significantly
                tempColor.lerp(colorShadow, 0.8);
            } else if (outerFactor > 0.3) {
                // BULGE: Highlight
                tempColor.lerp(colorHighlight, outerFactor * 0.6);
            }

            // --- KEY FIX: Top Brightness Attenuation ---
            // As t approaches 1.0 (the tip), particle density is extremely high due to geometry scaling down.
            // In Additive Blending, this causes over-exposure (pure white).
            // We multiply the color by a factor that decreases as t increases.
            // t=0 (bottom) -> factor=1.0
            // t=1 (top) -> factor=0.4 (60% darker)
            const heightAttenuation = 1.0 - Math.pow(t, 1.5) * 0.6;
            tempColor.multiplyScalar(heightAttenuation);

            // Halo Effect
            const isHalo = Math.random() > 0.96;
            if (isHalo) {
                tempColor.set(0xFFD700);
                tempColor.multiplyScalar(1.2);
                // Also attenuate halo at top, otherwise it looks like a supernova
                tempColor.multiplyScalar(heightAttenuation);
                sizes[i] = Math.random() * 2 + 0.5;
            } else {
                sizes[i] = Math.random() * 4 + 2;
            }

            colors[i * 3] = tempColor.r;
            colors[i * 3 + 1] = tempColor.g;
            colors[i * 3 + 2] = tempColor.b;

            // --- Random Position ---
            const rTheta = Math.random() * Math.PI * 2;
            const rDist = 40 + Math.random() * 80;
            const rY = (Math.random() - 0.5) * 80;
            
            randomPositions[i * 3] = rDist * Math.cos(rTheta);
            randomPositions[i * 3 + 1] = rY;
            randomPositions[i * 3 + 2] = rDist * Math.sin(rTheta);

            speeds[i] = Math.random() * 0.5 + 0.2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(randomPositions, 3));
        geometry.setAttribute('aTargetPos', new THREE.BufferAttribute(targetPositions, 3));
        geometry.setAttribute('aRandomPos', new THREE.BufferAttribute(randomPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

        // --- Shader Material ---
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uProgress: { value: 0.0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true,
            depthWrite: false,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, shaderMaterial);
        scene.add(particles);

        // --- Interaction Logic ---
        const state = { targetProgress: 0.0, currentProgress: 0.0 };
        const videoElement = document.getElementsByClassName('input_video')[0];
        const camStatus = document.getElementById('cam-status');
        const camText = document.getElementById('cam-text');
        const handStatus = document.getElementById('hand-status');
        const gestureText = document.getElementById('gesture-text');
        const loadingDiv = document.getElementById('loading');

        // Mouse Events
        window.addEventListener('mousedown', () => state.targetProgress = 1.0);
        window.addEventListener('mouseup', () => state.targetProgress = 0.0);
        window.addEventListener('touchstart', () => state.targetProgress = 1.0);
        window.addEventListener('touchend', () => state.targetProgress = 0.0);

        // MediaPipe
        function onResults(results) {
            loadingDiv.style.display = 'none';
            camStatus.classList.add('active');
            camStatus.classList.remove('error');
            camText.innerText = "ËøêË°å‰∏≠";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handStatus.classList.add('active');
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let foldedFingers = 0;
                
                tips.forEach(tipIdx => {
                    const tip = landmarks[tipIdx];
                    const knuckle = landmarks[tipIdx - 2];
                    if (dist(tip, wrist) < dist(knuckle, wrist) || dist(tip, wrist) < 0.35) foldedFingers++;
                });

                if (dist(landmarks[4], landmarks[5]) < 0.15) foldedFingers++;

                if (foldedFingers >= 3) {
                    gestureText.innerText = "Ê£ÄÊµãÂà∞: ‚úä Êè°Êã≥ (ËÅöÂêà)";
                    gestureText.style.color = "#00ff88";
                    state.targetProgress = 1.0;
                } else {
                    gestureText.innerText = "Ê£ÄÊµãÂà∞: üñê Âº†ÂºÄ (Êï£ÂºÄ)";
                    gestureText.style.color = "#ffdd44";
                    state.targetProgress = 0.0;
                }
            } else {
                handStatus.classList.remove('active');
                gestureText.innerText = "Êú™Ê£ÄÊµãÂà∞ÊâãÈÉ®";
                gestureText.style.color = "#888";
            }
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 640, height: 480
        });
        cameraUtils.start().catch(err => {
            console.error(err);
            camStatus.classList.add('error');
            camText.innerText = "Â§±Ë¥•";
            loadingDiv.innerText = "ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê";
        });

        // Loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            state.currentProgress += (state.targetProgress - state.currentProgress) * 0.04;
            shaderMaterial.uniforms.uTime.value = time;
            shaderMaterial.uniforms.uProgress.value = state.currentProgress;
            particles.rotation.y = time * (0.05 + state.currentProgress * 0.1);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>